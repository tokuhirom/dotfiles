#!/usr/bin/env perl
# slog - JSON 形式の slog ログを整形して表示
use strict;
use warnings;
use JSON::PP;

# ANSI color codes
my $RESET   = "\033[0m";
my $GREY    = "\033[38;5;59m";
my $BLUE    = "\033[34m";
my $GREEN   = "\033[32m";
my $YELLOW  = "\033[33m";
my $RED     = "\033[31m";
my $MAGENTA = "\033[35m";

# level ごとの色
my %LEVEL_COLOR = (
    DEBUG => $GREY,
    INFO  => $GREEN,
    WARN  => $YELLOW,
    ERROR => $RED,
    FATAL => $MAGENTA,
);

while (my $line = <STDIN>) {
    chomp $line;

    if ($line =~ /^\{/) {
        my $data = eval { decode_json($line) };
        if ($@) {
            print "$line\n";
            next;
        }

        # タイムスタンプ（秒まで）
        my $time_str = $data->{time} // '';
        if ($time_str =~ /T(\d{2}:\d{2}:\d{2})/) {
            $time_str = $1;
        }

        # level
        my $level = $data->{level} // 'UNKNOWN';
        my $level_color = $LEVEL_COLOR{uc $level} // $RESET;

        # msg
        my $msg = $data->{msg} // '';

        # 出力: timestamp [LEVEL] msg
        print "${GREY}${time_str}${RESET} ";
        print "[${level_color}${level}${RESET}] ";
        print $msg;

        # 無視するキー
        delete @{$data}{qw(time level msg source)};

        # extra fields を key=value 形式で表示
        if (keys %$data) {
            my @extras;
            for my $key (sort keys %$data) {
                my $val = $data->{$key};
                # undef の場合
                if (!defined $val) {
                    $val = 'null';
                }
                # 値が参照の場合は JSON 文字列に
                elsif (ref $val) {
                    $val = encode_json($val);
                }
                push @extras, "${GREY}${key}${RESET}=$val";
            }
            print " ", join(" ", @extras);
        }

        print "\n";
    } else {
        print "$line\n";
    }
}
